# TaskContext 只保存被调用者保存寄存器的原因分析

## 1. 寄存器分类（RISC-V ABI）

### 调用者保存寄存器 (Caller-Saved)
- **a0-a7** (x10-x17): 函数参数和返回值
- **t0-t6** (x5-x7, x28-x31): 临时寄存器
- **ra** (x1): 返回地址（特殊，需要在TaskContext中保存）

**特点**：调用函数前，调用者负责保存这些寄存器（如果需要）

### 被调用者保存寄存器 (Callee-Saved)
- **s0-s11** (x8-x9, x18-x27): 保存寄存器
- **sp** (x2): 栈指针

**特点**：函数内部使用前，被调用者负责保存这些寄存器

## 2. 两种上下文的作用

### TrapContext（陷阱上下文）
```rust
pub struct TrapContext {
    pub x: [usize; 32],      // 所有32个通用寄存器
    pub sstatus: Sstatus,    // 状态寄存器
    pub sepc: usize,         // 异常返回地址
    // ...
}
```
**作用**：保存用户态→内核态切换时的**完整现场**

**保存时机**：
- 进入内核时（`__alltraps`）
- 从用户态到内核态
- 需要保存所有寄存器，因为用户程序不知道中断何时发生

### TaskContext（任务上下文）
```rust
pub struct TaskContext {
    ra: usize,              // 返回地址
    sp: usize,              // 栈指针
    s: [usize; 12],         // s0-s11
}
```
**作用**：保存任务切换时的**最小必要现场**

**保存时机**：
- 在内核态内切换任务（`__switch`）
- 从一个任务的内核栈切换到另一个任务的内核栈
- 发生在函数调用边界

## 3. 为什么只需要保存被调用者保存寄存器？

### 场景：任务 A 切换到任务 B

```
Task A (内核态):
    trap_handler()
        ↓
    run_next_task()     ← 这是一个普通函数调用
        ↓
    __switch()          ← 在这里切换
```

### 关键理解：__switch 是一个"普通"函数调用

从调用者（`run_next_task`）的角度看：

1. **调用前**：
   - 编译器已经按照 RISC-V ABI 自动保存了需要的调用者保存寄存器（a0-a7, t0-t6）
   - 这些寄存器的值已经在当前栈帧中

2. **调用 __switch**：
   ```rust
   __switch(current_task_cx_ptr, next_task_cx_ptr);
   ```
   - 参数通过 a0, a1 传递
   - 根据 ABI，__switch 作为被调用者，必须保证 s0-s11 的值在返回后不变
   - 但 __switch 实际上不会"返回"到调用者，而是"返回"到另一个任务！

3. **__switch 内部**：
   ```assembly
   __switch:
       # 保存当前任务的上下文
       sd ra, 0(a0)         # 保存返回地址
       sd sp, 8(a0)         # 保存栈指针
       sd s0-s11, ...       # 保存 s0-s11
       
       # 恢复下一个任务的上下文
       ld ra, 0(a1)         # 恢复返回地址
       ld sp, 8(a1)         # 恢复栈指针（切换栈！）
       ld s0-s11, ...       # 恢复 s0-s11
       
       ret                  # "返回"到新任务
   ```

4. **为什么不需要保存 a0-a7, t0-t6？**
   - 这些寄存器已经被调用者（`run_next_task`）保存在栈上了
   - 当我们切换到新任务时，新任务有自己的应用内核栈
   - 当新任务再次切换回来时，会恢复 sp 和 ra，回到原来的栈帧
   - 此时调用者保存的寄存器值都还在栈上！

## 4. 实际例子

### 任务 A 第一次被切换出去：

```
Task A 的栈:
+------------------+
| run_next_task 的 |
| 栈帧（包含保存的  |
| t0, a0 等）      |
+------------------+ ← sp (保存在 TaskContext 中)
```

当 __switch 执行后：
- TaskContext.sp 保存了这个栈指针
- TaskContext.ra 保存了返回到 `run_next_task` 的地址
- TaskContext.s 保存了 s0-s11 的值

### 任务 A 被切换回来：

```assembly
__switch:
    # 恢复 Task A 的上下文
    ld sp, 8(a1)    # sp 指向 Task A 的栈
    ld ra, 0(a1)    # ra 指向 run_next_task 的返回地址
    ld s0-s11, ...  # 恢复 s0-s11
    ret             # 返回到 run_next_task
```

此时：
- sp 恢复了，栈帧完好无损
- ra 恢复了，知道返回到哪里
- s0-s11 恢复了，满足 ABI 要求
- 调用者保存的寄存器（t0, a0等）本来就在栈上，自动"恢复"了

## 5. 对比：如果不是函数调用边界

如果任务切换发生在任意位置（不是函数调用），就必须保存所有寄存器：

```
任意位置切换（类似信号处理）:
    - 不知道哪些寄存器正在使用
    - 不能依赖调用约定
    - 必须保存所有寄存器
```

这就是为什么 **TrapContext 保存所有寄存器**，而 **TaskContext 只保存被调用者保存寄存器**！

## 6. 总结

TaskContext 只保存被调用者保存寄存器的原因：

1. ✅ **任务切换发生在函数调用边界**（__switch 是一个函数）
2. ✅ **遵循 RISC-V ABI**：调用者已经保存了 caller-saved 寄存器
3. ✅ **栈的完整性**：恢复 sp 后，栈帧中的数据自然恢复
4. ✅ **最小化开销**：只保存必要的寄存器（ra + sp + s0-s11 = 14个），而不是32个

这是一个精妙的设计，利用了**函数调用约定**来减少任务切换的开销！

